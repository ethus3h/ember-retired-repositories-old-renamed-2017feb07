<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 4. Programming interface</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"><link rel="home" href="index.html" title="Recoll user manual"><link rel="up" href="index.html" title="Recoll user manual"><link rel="prev" href="RCL.SEARCH.DESKTOP.html" title="3.8. Desktop integration"><link rel="next" href="RCL.PROGRAM.FIELDS.html" title="4.2. Field data processing"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 4. Programming interface</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="RCL.SEARCH.DESKTOP.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="RCL.PROGRAM.FIELDS.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter 4. Programming interface"><div class="titlepage"><div><div><h2 class="title"><a name="RCL.PROGRAM"></a>Chapter 4. Programming interface</h2></div></div></div><p><span class="application">Recoll</span> has an Application Programming Interface, usable both
        for indexing and searching, currently accessible from the
        <span class="application">Python</span> language.</p><p>Another less radical way to extend the application is to
        write filters for new types of documents.</p><p>The processing of metadata attributes for documents
        (<code class="literal">fields</code>) is highly configurable.</p><div class="sect1" title="4.1. Writing a document filter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RCL.PROGRAM.FILTERS"></a>4.1. Writing a document filter</h2></div></div></div><p><span class="application">Recoll</span> filters cooperate to translate from the multitude
        of input document formats, simple ones
        as <span class="application">opendocument</span>, 
          <span class="application">acrobat</span>), or compound ones such
          as <span class="application">Zip</span>
          or <span class="application">Email</span>, into the final <span class="application">Recoll</span>
          indexing input format, which may
          be <code class="literal">text/plain</code>
          or <code class="literal">text/html</code>. Most filters are executable
          programs or scripts. A few filters are coded in C++ and live
          inside <span class="command"><strong>recollindex</strong></span>. This latter kind will not
          be described here.</p><p>There are currently (1.18 and since 1.13) two kinds of
        external executable filters:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Simple filters (<code class="literal">exec</code>
	        filters) run once and
	        exit. They can be bare programs
	        like <span class="application">antiword</span>, or scripts
	        using other programs. They are very simple to write,
	        because they just need to print the converted document
	        to the standard output. Their output can
	        be <code class="literal">text/plain</code>
	        or <code class="literal">text/html</code>.</p></li><li class="listitem"><p>Multiple filters (<code class="literal">execm</code>
	        filters), run as long as
	        their master process (<span class="command"><strong>recollindex</strong></span>) is
	        active. They can process multiple files (sparing the
	        process startup time which can be very significant),
	        or multiple documents per file (e.g.: for zip or chm
	        files). They communicate with the indexer through a
	        simple protocol, but are nevertheless a bit more
	        complicated than the older kind. Most of new
	        filters are written
	        in <span class="application">Python</span>, using a common
	        module to handle the protocol. There is an
	        exception, <span class="command"><strong>rclimg</strong></span> which is written
	        in Perl. The subdocuments output by these filters can
	        be directly indexable (text or HTML), or they can be
	        other simple or compound documents that will need to
	        be processed by another filter.</p></li></ul></div><p>
        </p><p>In both cases, filters deal with regular file system
          files, and can process either a single document, or a
          linear list of documents in each file. <span class="application">Recoll</span> is responsible
          for performing up to date checks, deal with more complex
          embedding and other upper level issues.</p><p>In the extreme case of a simple filter returning a
          document in <code class="literal">text/plain</code> format, no
          metadata can be transferred from the filter to the
          indexer. Generic metadata, like document size or
          modification date, will be gathered and stored by the
          indexer.</p><p>Filters that produce  <code class="literal">text/html</code>
          format can return an arbitrary amount of metadata inside HTML
          <code class="literal">meta</code> tags. These will be processed
          according to the directives found in 
          the <a class="link" href="RCL.PROGRAM.FIELDS.html" title="4.2. Field data processing">
            <code class="filename">fields</code> configuration
            file</a>.</p><p>The filters that can handle multiple documents per file
          return a single piece of data to identify each document inside
          the file. This piece of data, called
          an <code class="literal">ipath element</code> will be sent back by
          <span class="application">Recoll</span> to extract the document at query time, for previewing,
          or for creating a temporary file to be opened by a
          viewer.</p><p>The following section describes the simple
          filters, and the next one gives a few explanations about
          the <code class="literal">execm</code> ones. You could conceivably
          write a simple filter with only the elements in the
          manual. This will not be the case for the other ones, for
          which you will have to look at the code.</p><div class="sect2" title="4.1.1. Simple filters"><div class="titlepage"><div><div><h3 class="title"><a name="RCL.PROGRAM.FILTERS.SIMPLE"></a>4.1.1. Simple filters</h3></div></div></div><p><span class="application">Recoll</span> simple filters are usually shell-scripts, but this is in
        no way necessary. Extracting the text from the native format is the
        difficult part. Outputting the format expected by <span class="application">Recoll</span> is
        trivial. Happily enough, most document formats have translators or
        text extractors which can be called from the filter. In some cases
        the output of the translating program is completely appropriate,
        and no intermediate shell-script is needed.</p><p>Filters are called with a single argument which is the
        source file name. They should output the result to stdout.</p><p>When writing a filter, you should decide if it will output
      plain text or HTML. Plain text is simpler, but you will not be able
      to add metadata or vary the output character encoding (this will be
      defined in a configuration file). Additionally, some formatting may
      be easier to preserve when previewing HTML. Actually the deciding factor
      is metadata: <span class="application">Recoll</span> has a way to <a class="link" href="RCL.PROGRAM.html#RCL.PROGRAM.FILTERS.HTML" title="4.1.4. Filter HTML output">
      extract metadata from the HTML header and use it for field 
      searches.</a>.</p><p>The <code class="envar">RECOLL_FILTER_FORPREVIEW</code> environment
        variable (values <code class="literal">yes</code>, <code class="literal">no</code>)
        tells the filter if the operation is for indexing or
        previewing. Some filters use this to output a slightly different
        format, for example stripping uninteresting repeated keywords (ie:
        <code class="literal">Subject:</code> for email) when indexing. This is not
        essential.</p><p>You should look at one of the simple filters, for example
        <span class="command"><strong>rclps</strong></span> for a starting point.</p><p>Don't forget to make your filter executable before 
         testing !</p></div><div class="sect2" title='4.1.2. "Multiple" filters'><div class="titlepage"><div><div><h3 class="title"><a name="RCL.PROGRAM.FILTERS.MULTIPLE"></a>4.1.2. "Multiple" filters</h3></div></div></div><p>If you can program and want to write
          an <code class="literal">execm</code> filter, it should not be too
          difficult to make sense of one of the existing modules. For
          example, look at <span class="command"><strong>rclzip</strong></span> which uses Zip
          file paths as identifiers (<code class="literal">ipath</code>),
          and <span class="command"><strong>rclics</strong></span>, which uses an integer
          index. Also have a look at the comments inside
          the <code class="filename">internfile/mh_execm.h</code> file and
          possibly at the corresponding module.</p><p><code class="literal">execm</code> filters sometimes need to make
          a choice for the nature of the <code class="literal">ipath</code>
          elements that they use in communication with the
          indexer. Here are a few guidelines:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use ASCII or UTF-8 (if the identifier is an
                integer print it, for example, like printf %d would
                do).</p></li><li class="listitem"><p>If at all possible, the data should make some
              kind of sense when printed to a log file to help with 
                debugging.</p></li><li class="listitem"><p><span class="application">Recoll</span> uses a colon (<code class="literal">:</code>) as a
                separator to store a complex path internally (for
                deeper embedding). Colons inside
                the <code class="literal">ipath</code> elements output by a
                filter will be escaped, but would be a bad choice as a
                filter-specific separator (mostly, again, for
                debugging issues).</p></li></ul></div><p>
          In any case, the main goal is that it should
          be easy for the filter to extract the target document, given
          the file name and the <code class="literal">ipath</code>
          element.</p><p><code class="literal">execm</code> filters will also produce
          a document with a null <code class="literal">ipath</code>
          element. Depending on the type of document, this may have
          some associated data (e.g. the body of an email message), or
          none (typical for an archive file). If it is empty, this
          document will be useful anyway for some operations, as the
          parent of the actual data documents.</p></div><div class="sect2" title="4.1.3. Telling Recoll about the filter"><div class="titlepage"><div><div><h3 class="title"><a name="RCL.PROGRAM.FILTERS.ASSOCIATION"></a>4.1.3. Telling <span class="application">Recoll</span> about the filter</h3></div></div></div><p>There are two elements that link a file to the filter which
      should process it: the association of file to mime type and the
      association of a mime type with a filter.</p><p>The association of files to mime types is mostly based on
        name suffixes. The types are defined inside the
        <a class="link" href="RCL.INSTALL.CONFIG.html#RCL.INSTALL.CONFIG.MIMEMAP" title="5.4.3. The mimemap file">
        <code class="filename">mimemap</code> file</a>. Example:
</p><pre class="programlisting">

.doc = application/msword
</pre><p>
       If no suffix association is found for the file name, <span class="application">Recoll</span> will try
       to execute the <span class="command"><strong>file -i</strong></span> command to determine a
       mime type.</p><p>The association of file types to filters is performed in
      the <a class="link" href="RCL.INSTALL.CONFIG.html#RCL.INSTALL.CONFIG.MIMECONF" title="5.4.4. The mimeconf file">
      <code class="filename">mimeconf</code> file</a>. A sample will probably be
      of better help than a long explanation:</p><pre class="programlisting">

[index]
application/msword = exec antiword -t -i 1 -m UTF-8;\
     mimetype = text/plain ; charset=utf-8

application/ogg = exec rclogg

text/rtf = exec unrtf --nopict --html; charset=iso-8859-1; mimetype=text/html

application/x-chm = execm rclchm
</pre><p>The fragment specifies that:

      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">application/msword</code> files
            are processed by executing the <span class="command"><strong>antiword</strong></span>
            program, which outputs
            <code class="literal">text/plain</code> encoded in
            <code class="literal">utf-8</code>.</p></li><li class="listitem"><p><code class="literal">application/ogg</code> files are
            processed by the <span class="command"><strong>rclogg</strong></span> script, with
            default output type (<code class="literal">text/html</code>, with
            encoding specified in the header, or <code class="literal">utf-8</code>
            by default).</p></li><li class="listitem"><p><code class="literal">text/rtf</code> is processed by
            <span class="command"><strong>unrtf</strong></span>, which outputs
            <code class="literal">text/html</code>. The 
            <code class="literal">iso-8859-1</code> encoding is specified because it
            is not the <code class="literal">utf-8</code> default, and not output by
            <span class="command"><strong>unrtf</strong></span> in the HTML header section.</p></li><li class="listitem"><p><code class="literal">application/x-chm</code> is processed
	      by a persistant filter. This is determined by the
	      <code class="literal">execm</code> keyword.</p></li></ul></div><p>
       </p></div><div class="sect2" title="4.1.4. Filter HTML output"><div class="titlepage"><div><div><h3 class="title"><a name="RCL.PROGRAM.FILTERS.HTML"></a>4.1.4. Filter HTML output</h3></div></div></div><p>The output HTML could be very minimal like the following
        example:
          </p><pre class="programlisting">
&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt;
  &lt;/head&gt;
  &lt;body&gt;
   Some text content
  &lt;/body&gt;
&lt;/html&gt;
          </pre><p>
        </p><p>You should take care to escape some
          characters inside the text by transforming them into
          appropriate entities. At the very minimum,
          "<code class="literal">&amp;</code>" should be transformed into
          "<code class="literal">&amp;amp;</code>", "<code class="literal">&lt;</code>"
          should be transformed into
          "<code class="literal">&amp;lt;</code>". This is not always properly
          done by translating programs which output HTML, and of
          course never by those which output plain text. </p><p>When encapsulating plain text in an HTML body, 
          the display of a preview may be improved by enclosing the
          text inside <code class="literal">&lt;pre&gt;</code> tags.</p><p>The character set needs to be specified in the
          header. It does not need to be UTF-8 (<span class="application">Recoll</span> will take care
          of translating it), but it must be accurate for good
          results.</p><p><span class="application">Recoll</span> will process <code class="literal">meta</code> tags inside
          the header as possible document fields candidates. Documents
          fields can be processed by the indexer in different ways,
          for searching or displaying inside query results. This is
          described in a <a class="link" href="RCL.PROGRAM.FIELDS.html" title="4.2. Field data processing">following
          section.</a>
        </p><p>By default, the indexer will process the standard header
          fields if they are present: <code class="literal">title</code>,
          <code class="literal">meta/description</code>,
          and <code class="literal">meta/keywords</code> are both indexed and stored
          for query-time display.</p><p>A predefined non-standard <code class="literal">meta</code> tag
          will also be processed by <span class="application">Recoll</span> without further
          configuration: if a <code class="literal">date</code> tag is present
          and has the right format, it will be used as the document
          date (for display and sorting), in preference to the file
          modification date. The date format should be as follows:
          </p><pre class="programlisting">
&lt;meta name="date" content="YYYY-mm-dd HH:MM:SS"&gt;
or
&lt;meta name="date" content="YYYY-mm-ddTHH:MM:SS"&gt;
          </pre><p>
          Example:
          </p><pre class="programlisting">
&lt;meta name="date" content="2013-02-24 17:50:00"&gt;
          </pre><p>
        </p><p>Filters also have the possibility to "invent" field
          names. This should also be output as meta tags:</p><pre class="programlisting">
&lt;meta name="somefield" content="Some textual data" /&gt;
</pre><p>You can embed HTML markup inside the content of custom
        fields, for improving the display inside result lists. In this
        case, add a (wildly non-standard) <code class="literal">markup</code>
        attribute to tell <span class="application">Recoll</span> that the value is HTML and should not
        be escaped for display.</p><pre class="programlisting">
&lt;meta name="somefield" markup="html" content="Some &lt;i&gt;textual&lt;/i&gt; data" /&gt;
</pre><p>As written above, the processing of fields is described
          in a <a class="link" href="RCL.PROGRAM.FIELDS.html" title="4.2. Field data processing">further
          section</a>.</p></div><div class="sect2" title="4.1.5. Page numbers"><div class="titlepage"><div><div><h3 class="title"><a name="RCL.PROGRAM.FILTERS.PAGES"></a>4.1.5. Page numbers</h3></div></div></div><p>The indexer will interpret <code class="literal">^L</code> characters
          in the filter output as indicating page breaks, and will record
          them. At query time, this allows starting a viewer on the right
          page for a hit or a snippet. Currently, only the PDF, Postscript
          and DVI filters generate page breaks.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="RCL.SEARCH.DESKTOP.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="RCL.PROGRAM.FIELDS.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3.8. Desktop integration </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.2. Field data processing</td></tr></table></div></body></html>
